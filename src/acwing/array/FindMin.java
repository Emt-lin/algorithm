package acwing.array;

/**
 * @author psl
 * @date 2019/8/10
 *              旋转数组的最小数字
 * 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。
 * 输入一个升序的数组的一个旋转，输出旋转数组的最小元素。
 * 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。
 * 数组可能包含重复项。
 * 注意：数组内所含元素非负，若数组大小为0，请返回-1。
 * 样例
 * 输入：nums=[2,2,2,0,1]
 *
 * 输出：0
 *      解题思路：
 *          就是利用两边都是呈现非递减序列，而且右边的非递减序列始终小于等于右边的，
 *          减去最右边与下标为0的元素相等的元素，然后采用二分法进行相关的操作
 *          分析图：见:  image/FindMin分析图.png
 *      时间复杂度：
 *        二分的时间复杂度是 O(logn)，删除最后水平一段的时间复杂度最坏是 O(n)，
 *          所以总时间复杂度是 O(n)。
 */
public class FindMin {
    public int findMin(int[] nums) {
        //得到数组最后一个位置坐标
        int n = nums.length - 1;
        //若数组大小为0，请返回-1
        if (n < 0) return -1;
        //就是排除旋转数组中最后面的元素等于坐标为0的元素，所以n--
        while (n > 0 && nums[n] == nums[0]) n--;
        //如果n的值已经到了前面递增的序列，最小值就是0号元素
        if (nums[n] >= nums[0]) return nums[0];
        //采用二分法
        int l = 0 ,r = n;
        while (l < r) {
            int mid = l + r >> 1;   //[l,mid]   [mid+1,r]
            //如果mid的元素大于0号位置的值，就继续向左走
            if (nums[mid] < nums[0]) r = mid;
            //否则，最小值在右边，向右走
            else l = mid + 1;
        }
        return nums[r];
    }
}
